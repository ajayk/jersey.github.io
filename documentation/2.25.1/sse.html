<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;15.&nbsp;Server-Sent Events (SSE) Support</title><link rel="stylesheet" type="text/css" href="/documentation.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Jersey 2.25.1 User Guide"><link rel="up" href="index.html" title="Jersey 2.25.1 User Guide"><link rel="prev" href="resource-builder.html" title="Chapter&nbsp;14.&nbsp;Programmatic API for Building Resources"><link rel="next" href="security.html" title="Chapter&nbsp;16.&nbsp;Security"><script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-3160303-1']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script></head><body class="contents"><div class="contents" bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;15.&nbsp;Server-Sent Events (SSE) Support</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="resource-builder.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="security.html">Next</a></td></tr></table><hr></div><div style="float:right"><a href="https://jersey.java.net"><img src="https://jersey.java.net/images/jersey_logo.png"></a></div><small>Links:
            <a href="index.html">
                Table of Contents
            </a> | <a href="user-guide.html">
                Single HTML
            </a></small><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="sse"></a>Chapter&nbsp;15.&nbsp;Server-Sent Events (SSE) Support</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="sse.html#d0e11463">15.1. What are Server-Sent Events</a></span></dt><dt><span class="section"><a href="sse.html#d0e11506">15.2. When to use Server-Sent Events</a></span></dt><dt><span class="section"><a href="sse.html#overview">15.3. Jersey Server-Sent Events API</a></span></dt><dt><span class="section"><a href="sse.html#d0e11668">15.4. Implementing SSE support in a JAX-RS resource</a></span></dt><dd><dl><dt><span class="section"><a href="sse.html#d0e11671">15.4.1. Simple SSE resource method</a></span></dt><dt><span class="section"><a href="sse.html#d0e11862">15.4.2. Broadcasting with Jersey SSE</a></span></dt></dl></dd><dt><span class="section"><a href="sse.html#d0e11970">15.5. Consuming SSE events with Jersey clients</a></span></dt><dd><dl><dt><span class="section"><a href="sse.html#d0e11986">15.5.1. Reading SSE events with <code class="literal">EventInput</code></a></span></dt><dt><span class="section"><a href="sse.html#d0e12060">15.5.2. Asynchronous SSE processing with <code class="literal">EventSource</code></a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11463"></a>15.1.&nbsp;What are Server-Sent Events</h2></div></div></div><p>
            In a standard HTTP request-response scenario a client opens a connection, sends a HTTP request to the server (for
            example a HTTP <code class="literal">GET</code> request), then receives a HTTP response back and the server closes the connection once
            the response is fully sent/received. The initiative <span class="emphasis"><em>always</em></span> comes from a client when the client
            requests all the data. In contrast, <span class="emphasis"><em>Server-Sent Events (SSE)</em></span> is a mechanism that allows server
            to asynchronously push the data from the server to the client once the client-server connection is established by the
            client. Once the connection is established by the client, it is the server who provides the data and decides
            to send it to the client whenever new "chunk" of data is available. When a new data event occurs on the server,
            the data event is sent by the server to the client. Thus the name Server-Sent Events. Note that at high level there
            are more technologies working on this principle, a short overview of the technologies supporting server-to-client
            communication is in this list:

            </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Polling</span></dt><dd><p>
                            With polling a client repeatedly sends new requests to a server. If the server has no new data,
                            then it send appropriate indication and closes the connection. The client then waits a bit and sends
                            another request after some time (after one second, for example).
                        </p></dd><dt><span class="term">Long-polling</span></dt><dd><p>
                            With long-polling a client sends a request to a server. If the server has no new data,
                            it just holds the connection open and waits until data is available. Once the server has data
                            (message) for the client, it uses the connection and sends it back to the client. Then the connection
                            is closed.
                        </p></dd><dt><span class="term">Server-Sent events</span></dt><dd><p>
                            SSE is similar to the long-polling mechanism, except it does not send only one message per connection.
                            The client sends a request and server holds a connection until a new message is ready, then it sends
                            the message back to the client while still keeping the connection open so that it can be used
                            for another message once it becomes available. Once a new message is ready, it is sent back to the
                            client on the same initial connection. Client processes the messages sent back from the server
                            individually without closing the connection after processing each message.
                            So, SSE typically reuses one connection for more messages (called events). SSE also defines a
                            dedicated media type that describes a simple format of individual events sent from the server to the
                            client. SSE also offers standard javascript client API implemented most modern browsers. For more
                            information about SSE, see the
                            <a class="link" href="http://www.w3.org/TR/2009/WD-eventsource-20091029/" target="_top">SSE API specification</a>.
                        </p></dd><dt><span class="term">WebSocket</span></dt><dd><p>
                            WebSocket technology is different from previous technologies as it provides a real full duplex
                            connection. The initiator is again a client which sends a request to a server with a special HTTP
                            header that informs the server that the HTTP connection may be "upgraded" to a full duplex TCP/IP
                            WebSocket connection. If server supports WebSocket, it may choose to do so. Once a WebSocket
                            connection is established, it can be used for bi-directional communication between the client and the
                            server. Both client and server can then send data to the other party at will whenever it is needed.
                            The communication on the new WebSocket connection is no longer based on HTTP protocol and can be
                            used for example for for online gaming or any other applications that require fast exchange of small
                            chunks of data in flowing in both directions.
                        </p></dd></dl></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11506"></a>15.2.&nbsp;When to use Server-Sent Events</h2></div></div></div><p>
            As explained above, SSE is a technology that allows clients to subscribe to event notifications that originate on
            a server. Server generates new events and sends these events back to the clients subscribed to receive the
            notifications. In other words, SSE offers a solution for a one-way publish-subscribe model.
        </p><p>
            A good example of the use case where SSE can be used is a simple message exchange RESTful service. Clients
            <code class="literal">POST</code> new messages to the service and subscribe to receive messages from other clients.
            Let's call the resource <code class="literal">messages</code>. While <code class="literal">POST</code>ing a new message to this resource involves
            a typical HTTP request-response communication between a client and the <code class="literal">messages</code> resource,
            subscribing to receive all new message notifications would be hard and impractical to model with a sequence of
            standard request-response message exchanges. Using Server-sent events provides a much more practical approach here.
            You can use SSE to let clients subscribe to the <code class="literal">messages</code> resource via standard <code class="literal">GET</code>
            request (use a SSE client API, for example javascript API or Jersey Client SSE API) and let the server broadcast
            new messages to all connected clients in the form of individual events (in our case using Jersey Server SSE API).
            Note that with Jersey a SSE support is implemented as an usual JAX-RS resource method. There's no need to do anything
            special to provide a SSE support in your Jersey/JAX-RS applications, your SSE-enabled resources are a standard part of
            your RESTful Web application that defines the REST API of your application. The following chapters describes SSE
            support in Jersey in more details.
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                Note, that while SSE in Jersey is supported with standard JAX-RS resources, Jersey SSE APIs are not part of
                the JAX-RS specification. SSE support and related APIs are a Jersey specific feature that extends JAX-RS.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="overview"></a>15.3.&nbsp;Jersey Server-Sent Events API</h2></div></div></div><p>
            This chapter briefly describes the Jersey support for SSE. Details and examples will be covered
            in chapters below.
        </p><p>
            Jersey contains support for SSE for both - server and client. SSE in Jersey is implemented as an extension
            supporting a new media type, which means that SSE really treated as just another media type that can be returned from
            a resource method and processed by the client. There is only a minimal additional support for "chunked" messages
            added to Jersey which could not be implemented as standard JAX-RS media type extension.
        </p><p>
            Before you start working with Jersey SSE, in order to add support for SSE you need to include the dependency to the
            <span class="emphasis"><em>SSE media type module</em></span>:
            </p><div class="example"><a name="sse.dependency"></a><p class="title"><b>Example&nbsp;15.1.&nbsp;Add <code class="literal">jersey-media-sse</code> dependency.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-sse&lt;/artifactId&gt;
&lt;/dependency&gt;</pre></div></div><p><br class="example-break">
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Prior to Jersey 2.8, you had to manually register <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/SseFeature.html" target="_top">SseFeature</a> in your application.
                    (The <code class="literal">SseFeature</code> is a feature that can be registered for both, the client and the server.)
                    Since Jersey 2.8, the feature gets automatically discovered and registered when Jersey SSE module is
                    put on the application's classpath. The automatic discovery and registration of SSE feature can be suppressed
                    by setting <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/SseFeature.html#DISABLE_SSE" target="_top">DISABLE_SSE</a> property to <code class="literal">true</code>.
                    The behavior can also be selectively suppressed in either client or server runtime by setting
                    <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/SseFeature.html#DISABLE_SSE_CLIENT" target="_top">DISABLE_SSE_CLIENT</a> or <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/SseFeature.html#DISABLE_SSE_SERVER" target="_top">DISABLE_SSE_SERVER</a> property
                    respectively.
                </p></div><p>
        </p><p>
            <code class="literal">SseFeature</code> adds new supported entity (representation) Java types, namely <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/OutboundEvent.html" target="_top">OutboundEvent</a>
            for the outbound server events and <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/InboundEvent.html" target="_top">InboundEvent</a> for inbound client events. These types are serialized by
            <code class="literal">OutboundEventWriter</code> and de-serialized by <code class="literal">InboundEventReader</code>.
            There is no restriction for a media type used in individual event messages; however the media type used for a SSE
            stream as whole is <span class="emphasis"><em>"text/event-stream"</em></span> and this media type should be set on messages that
            are used to serve SSE events (for example on the server side using <a class="link" href="https://jersey.java.net/apidocs-javax.jax-rs/2.0.1/javax/ws/rs/Produces.html" target="_top">@Produces</a> on the method that returns an
            <code class="literal">EventOutput</code> - see below).
            The <code class="literal">InboundEvent</code> and <code class="literal">OutboundEvent</code> contain all the fields needed for composing
            and processing individual SSE events. These entities represent the <span class="emphasis"><em>chunks</em></span> sent or received over
            an open server-to-client connection that is represented by an <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/server/ChunkedOutput.html" target="_top">ChunkedOutput</a> on the servers side and
            <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/client/ChunkedInput.html" target="_top">ChunkedInput</a> on the client side (if you are not familiar with
            <code class="literal">ChunkedOutput</code> and <code class="literal">ChunkedInput</code>, see the
            <a class="link" href="async.html" title="Chapter&nbsp;11.&nbsp;Asynchronous Services and Clients">Async chapter</a> first for more details). In other words, our resource method that is used
            to open a SSE connection to a client does not return individual <code class="literal">OutboundEvent</code>s. Instead, a new
            instance of <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/EventOutput.html" target="_top">EventOutput</a> is returned. <code class="literal">EventOutput</code> is a typed extension of
            <code class="literal">ChunkedOutput&lt;OutboundEvent&gt;</code>. Similarly, to receive <code class="literal">InboundEvent</code>s on a
            client side, Jersey SSE API provides a <code class="literal">EventInput</code> that represents a typed extension of
            <code class="literal">ChunkedInput&lt;InboundEvent&gt;</code>.
        </p><p>
            The Jersey server SSE API also contains a <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/SseBroadcaster.html" target="_top">SseBroadcaster</a> utility, that provides a convenient way of
            grouping multiple <code class="literal">EventOutput</code> instances that represent individual client connections into a
            group, and exposes methods for broadcasting new events to all the client connections grouped in the broadcaster.
            The <code class="literal">SseBroadcaster</code> inherits from <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/server/Broadcaster.html" target="_top">Broadcaster</a> which is the generic broadcaster
            implementation of the Jersey chunked message processing facility.
            On the client side, the Jersey SSE API contains additional <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/EventSource.html" target="_top">EventSource</a> and <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/EventListener.html" target="_top">EventListener</a>
            classes that further improve convenience of processing new inbound SSE events.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11668"></a>15.4.&nbsp;Implementing SSE support in a JAX-RS resource</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11671"></a>15.4.1.&nbsp;Simple SSE resource method</h3></div></div></div><p>
                Firstly you need to add a <a class="link" href="sse.html#sse.dependency" title="Example&nbsp;15.1.&nbsp;Add jersey-media-sse dependency.">Jersey SSE module dependency</a> to your project
                as shown in the earlier section and register the <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/SseFeature.html" target="_top">SseFeature</a> from this module in your
                <a class="link" href="https://jersey.java.net/apidocs-javax.jax-rs/2.0.1/javax/ws/rs/core/Application.html" target="_top">Application</a> or <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a>. Once done, you are ready to add SSE support
                to your resource:

                </p><div class="example"><a name="example-simple-sse"></a><p class="title"><b>Example&nbsp;15.2.&nbsp;Simple SSE resource method</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import org.glassfish.jersey.media.sse.EventOutput;
import org.glassfish.jersey.media.sse.OutboundEvent;
import org.glassfish.jersey.media.sse.SseFeature;
...

@Path("events")
public static class SseResource {

    @GET
    @Produces(SseFeature.SERVER_SENT_EVENTS)
    public EventOutput getServerSentEvents() {
        final EventOutput eventOutput = new EventOutput();
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    for (int i = 0; i &lt; 10; i++) {
                        // ... code that waits 1 second
                        final OutboundEvent.Builder eventBuilder
                        = new OutboundEvent.Builder();
                        eventBuilder.name("message-to-client");
                        eventBuilder.data(String.class,
                            "Hello world " + i + "!");
                        final OutboundEvent event = eventBuilder.build();
                        eventOutput.write(event);
                    }
                } catch (IOException e) {
                    throw new RuntimeException(
                        "Error when writing the event.", e);
                } finally {
                    try {
                        eventOutput.close();
                    } catch (IOException ioClose) {
                        throw new RuntimeException(
                            "Error when closing the event output.", ioClose);
                    }
                }
            }
        }).start();
        return eventOutput;
    }
}</pre></div></div><p><br class="example-break">

                The code above defines the resource deployed on URI <code class="literal">"/events"</code>. This resource has a single
                <a class="link" href="https://jersey.java.net/apidocs-javax.jax-rs/2.0.1/javax/ws/rs/GET.html" target="_top">@GET</a> resource method which returns as an entity <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/EventOutput.html" target="_top">EventOutput</a> - an extension of generic Jersey
                <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/server/ChunkedOutput.html" target="_top">ChunkedOutput</a> API for output chunked message processing.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        If you are not familiar with
                        <code class="literal">ChunkedOutput</code> and <code class="literal">ChunkedInput</code>, see the
                        <a class="link" href="async.html" title="Chapter&nbsp;11.&nbsp;Asynchronous Services and Clients">Async chapter</a> first for more details.
                    </p></div><p>
                After the <code class="literal">eventOutput</code> is returned from the method, the Jersey runtime recognizes that this is
                a <code class="literal">ChunkedOutput</code> extension and does not close the client connection immediately. Instead, it
                writes the HTTP headers to the response stream and waits for more chunks (SSE events) to be sent. At this point
                the client can read headers and starts listening for individual events.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        Since Jersey runtime does not implicitly close the connection to the client (similarly to asynchronous
                        processing), closing the connection is a responsibility of the resource method or the client listening
                        on the open connection for new events (see following example).
                    </p></div><p>
            </p><p>
                In the <a class="xref" href="sse.html#example-simple-sse" title="Example&nbsp;15.2.&nbsp;Simple SSE resource method">Example&nbsp;15.2, &#8220;Simple SSE resource method&#8221;</a>, the resource method creates a new thread that sends a sequence of
                10 events. There is a 1 second delay between two subsequent events as indicated in a comment. Each event is
                represented by <code class="literal">OutboundEvent</code> type and is built with a helpf of an outbound event
                <code class="literal">Builder</code>. The <code class="literal">OutboundEvent</code> reflects the standardized format of SSE messages
                and contains properties that represent <code class="literal">name</code> (for named
                events), <code class="literal">comment</code>, <code class="literal">data</code> or <code class="literal">id</code>. The code also sets the
                event data media type using the <code class="literal">mediaType(MediaType)</code> method on the
                <code class="literal">eventBuilder</code>. The media type, together with the data type set by the
                <code class="literal">data(Class, Object&gt;</code> method (in our case <code class="literal">String.class</code>), is used
                for serialization of the event data. Note that the event data media type will not be written to any headers as
                the response <code class="literal">Content-type</code> header is already defined by the <code class="literal">@Produces</code> and set to
                <code class="literal">"text/event-stream"</code> using constant from the <code class="literal">SseFeature</code>.
                The event media type is used for serialization of event <code class="literal">data</code>. Event data media type and Java
                type are used to select the proper <a class="link" href="https://jersey.java.net/apidocs-javax.jax-rs/2.0.1/javax/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> for event data serialization and are passed
                to the selected writer that serializes the event <code class="literal">data</code> content. In our case the string
                <code class="literal">"Hello world " + i + "!"</code> is serialized as <code class="literal">"text/plain"</code>. In event
                <code class="literal">data</code> you can send any Java entity and associate it with any media type that you would be able
                to serialize with an available <code class="literal">MessageBodyWriter&lt;T&gt;</code>. Typically, you may want to send e.g. JSON data,
                so you would fill the <code class="literal">data</code> with a JAXB annotated bean instance and define media type to JSON.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        If the event media type is not set explicitly, the <code class="literal">"text/plain"</code> media type is used
                        by default.
                    </p></div><p>
            </p><p>
                Once an outbound event is ready, it can be written to the <code class="literal">eventOutput</code>. At that point the event
                is serialized by internal <code class="literal">OutboundEventWriter</code> which uses an appropriate
                <code class="literal">MessageBodyWriter&lt;T&gt;</code> to serialize the <code class="literal">"Hello world " + i + "!"</code> string. You can
                send as many messages as you like. At the end of the thread execution the response is closed which also closes
                the connection to the client. After that, no more messages can be sent to the client on this connection. If the
                client would like to receive more messages, it would have to send a new request to the server to initiate a
                new SSE streaming connection.
            </p><p>
                A client connecting to our SSE-enabled resource will receive the following data from the entity stream:

                </p><pre class="screen">event: message-to-client
data: Hello world 0!

event: message-to-client
data: Hello world 1!

event: message-to-client
data: Hello world 2!

event: message-to-client
data: Hello world 3!

event: message-to-client
data: Hello world 4!

event: message-to-client
data: Hello world 5!

event: message-to-client
data: Hello world 6!

event: message-to-client
data: Hello world 7!

event: message-to-client
data: Hello world 8!

event: message-to-client
data: Hello world 9!</pre><p>

                Each message is received with a delay of one second.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    If you have worked with streams in JAX-RS, you may wonder what is the difference between
                    <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/server/ChunkedOutput.html" target="_top">ChunkedOutput</a> and <a class="link" href="https://jersey.java.net/apidocs-javax.jax-rs/2.0.1/javax/ws/rs/core/StreamingOutput.html" target="_top">StreamingOutput</a>.
                </p><p>
                    <code class="literal">ChunkedOutput</code> is Jersey-specific API. It lets you send "chunks" of data without closing
                    the client connection using series of convenient calls to <code class="literal">ChunkedOutput.write</code> methods
                    that take POJO + chunk media type as an input and then use the configured JAX-RS
                    <code class="literal">MessageBodyWriter&lt;T&gt;</code> providers to figure out the proper way of serializing each chunk POJO
                    to bytes. Additionally, <code class="literal">ChunkedOutput</code> writes can be invoked multiple times on the same
                    outbound response connection, i.e. individual chunks are written in each write, not the full response entity.
                </p><p>
                    <code class="literal">StreamingOutput</code> is, on the other hand, a low level JAX-RS API that works with bytes
                    directly. You have to implement <code class="literal">StreamingOutput</code> interface yourself. Also, its
                    <code class="literal">write(OutputStream)</code> method will be invoked by JAX-RS runtime only once per response
                    and the call to this method is blocking, i.e. the method is expected to write the entire entity body
                    before returning.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11862"></a>15.4.2.&nbsp;Broadcasting with Jersey SSE</h3></div></div></div><p>
                Jersey SSE server API defines <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/SseBroadcaster.html" target="_top">SseBroadcaster</a> which allows to broadcast individual events to multiple
                clients. A simple broadcasting implementation is shown in the following example:

                </p><div class="example"><a name="d0e11870"></a><p class="title"><b>Example&nbsp;15.3.&nbsp;Broadcasting SSE messages</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import org.glassfish.jersey.media.sse.SseBroadcaster;
...

@Singleton
@Path("broadcast")
public static class BroadcasterResource {

    private SseBroadcaster broadcaster = new SseBroadcaster();

    @POST
    @Produces(MediaType.TEXT_PLAIN)
    @Consumes(MediaType.TEXT_PLAIN)
    public String broadcastMessage(String message) {
        OutboundEvent.Builder eventBuilder = new OutboundEvent.Builder();
        OutboundEvent event = eventBuilder.name("message")
            .mediaType(MediaType.TEXT_PLAIN_TYPE)
            .data(String.class, message)
            .build();

        broadcaster.broadcast(event);

        return "Message '" + message + "' has been broadcast.";
    }

    @GET
    @Produces(SseFeature.SERVER_SENT_EVENTS)
    public EventOutput listenToBroadcast() {
        final EventOutput eventOutput = new EventOutput();
        this.broadcaster.add(eventOutput);
        return eventOutput;
    }
}</pre></div></div><p><br class="example-break">

                Let's explore the example together. The <code class="literal">BroadcasterResource</code> resource class is annotated with
                <a class="link" href="http://docs.oracle.com/javaee/7/api/javax/inject/Singleton.html" target="_top">@Singleton</a> annotation which tells Jersey runtime that only a single instance of the resource
                class should be used to serve all the incoming requests to <code class="literal">/broadcast</code> path. This is needed as
                we want to keep an application-wide single reference to the private <code class="literal">broadcaster</code> field so that
                we can use the same instance for all requests. Clients that want to listen to SSE events first send a
                <code class="literal">GET</code> request to the <code class="literal">BroadcasterResource</code>, that is handled by the
                <code class="literal">listenToBroadcast()</code> resource method.
                The method creates a new <code class="literal">EventOutput</code> representing the connection to the requesting client
                and registers this <code class="literal">eventOutput</code> instance with the singleton <code class="literal">broadcaster</code>,
                using its <code class="literal">add(EventOutput)</code> method. The method then returns the <code class="literal">eventOutput</code>
                which causes Jersey to bind the <code class="literal">eventOutput</code> instance with the requesting client and send the
                response HTTP headers to the client. The client connection remains open and the client is now waiting ready to
                receive new SSE events. All the events are written to the <code class="literal">eventOutput</code> by
                <code class="literal">broadcaster</code> later on. This way developers can conveniently handle sending new events to
                all the clients that subscribe to them.
            </p><p>
                When a client wants to broadcast new message to all the clients listening on their SSE connections,
                it sends a <code class="literal">POST</code> request to <code class="literal">BroadcasterResource</code> resource with the message content.
                The method <code class="literal">broadcastMessage(String)</code> is invoked on <code class="literal">BroadcasterResource</code>
                resource with the message content as an input parameter. A new SSE outbound event is built in the standard way
                and passed to the broadcaster. The broadcaster internally invokes <code class="literal">write(OutboundEvent)</code> on all
                registered <code class="literal">EventOutput</code>s. After that the method just return a standard text response
                to the <code class="literal">POST</code>ing client to inform the client that the message was successfully broadcast. As you can see,
                the <code class="literal">broadcastMessage(String)</code> resource method is just a simple JAX-RS resource method.
            </p><p>
                In order to implement such a scenario, you may have noticed, that the Jersey  <code class="literal">SseBroadcaster</code>
                is not mandatory to complete the use case. individual <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/EventOutput.html" target="_top">EventOutput</a>s can be just stored in a collection
                and iterated over in the <code class="literal">broadcastMessage</code> method. However, the <code class="literal">SseBroadcaster</code>
                internally identifies and handles also client disconnects. When a client closes the connection the broadcaster
                detects this and removes the stale connection from the internal collection of the registered
                <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/EventOutput.html" target="_top">EventOutput</a>s as well as it frees all the server-side resources associated with the stale connection.
                Additionally, the <code class="literal">SseBroadcaster</code> is implemented to be thread-safe, so that clients can connect
                and disconnect in any time and <code class="literal">SseBroadcaster</code> will always broadcast messages to the most recent
                collection of registered and active set of clients.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11970"></a>15.5.&nbsp;Consuming SSE events with Jersey clients</h2></div></div></div><p>
            On the client side, Jersey exposes APIs that support receiving and processing SSE events using two programming models:

            </p><table border="0" summary="Simple list" class="simplelist"><tr><td>Pull model - pulling events from a <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/EventInput.html" target="_top">EventInput</a>, or</td></tr><tr><td>Push model - listening for asynchronous notifications of <code class="literal">EventSource</code></td></tr></table><p>

            Both models will be described.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11986"></a>15.5.1.&nbsp;Reading SSE events with <code class="literal">EventInput</code></h3></div></div></div><p>
                The events can be read on the client side from a <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/EventInput.html" target="_top">EventInput</a>. See the following code:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newBuilder()
        .register(SseFeature.class).build();
WebTarget target = client.target("http://localhost:9998/events");

EventInput eventInput = target.request().get(EventInput.class);
while (!eventInput.isClosed()) {
    final InboundEvent inboundEvent = eventInput.read();
    if (inboundEvent == null) {
        // connection has been closed
        break;
    }
    System.out.println(inboundEvent.getName() + "; "
        + inboundEvent.readData(String.class));
}</pre><p>

                In this example, a client connects to the server where the <code class="literal">SseResource</code> from the
                <a class="xref" href="sse.html#example-simple-sse" title="Example&nbsp;15.2.&nbsp;Simple SSE resource method">Example&nbsp;15.2, &#8220;Simple SSE resource method&#8221;</a> is deployed. At first, a new JAX-RS/Jersey <code class="literal">client</code>
                instance is created with a <code class="literal">SseFeature</code> registered. Then a <a class="link" href="https://jersey.java.net/apidocs-javax.jax-rs/2.0.1/javax/ws/rs/client/WebTarget.html" target="_top">WebTarget</a> instance is
                retrieved from the <code class="literal">client</code> and is used to invoke a HTTP request. The returned response entity
                is directly read as a <code class="literal">EventInput</code> Java type, which is an extension of Jersey
                <code class="literal">ChunkedInput</code> that provides generic support for consuming chunked message payloads. The
                code in the example then process starts a loop to process the inbound SSE events read from the
                <code class="literal">eventInput</code> response stream. Each chunk read from the input is a <code class="literal">InboundEvent</code>.
                The method <code class="literal">InboundEvent.readData(Class)</code> provides a way for the client to indicate what Java type
                should be used for the event data de-serialization. In our example, individual events are de-serialized as
                 <code class="literal">String</code> Java type instances. This method internally finds and executes a proper
                <a class="link" href="https://jersey.java.net/apidocs-javax.jax-rs/2.0.1/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> which is the used to do the actual de-serialization. This is similar to reading an
                entity from the <a class="link" href="https://jersey.java.net/apidocs-javax.jax-rs/2.0.1/javax/ws/rs/core/Response.html" target="_top">Response</a> by <code class="literal">readEntity(Class)</code>. The method
                <code class="literal">readData</code> can also throw a <a class="link" href="https://jersey.java.net/apidocs-javax.jax-rs/2.0.1/javax/ws/rs/ProcessingException.html" target="_top">ProcessingException</a>.
            </p><p>
                The <code class="literal">null</code> check on <code class="literal">inboundEvent</code> is necessary to make sure that the chunk was properly
                read and connection has not been closed by the server. Once the connection is closed, the loop terminates and
                the program completes execution. The client code produces the following console output:

                </p><pre class="screen">message-to-client; Hello world 0!
message-to-client; Hello world 1!
message-to-client; Hello world 2!
message-to-client; Hello world 3!
message-to-client; Hello world 4!
message-to-client; Hello world 5!
message-to-client; Hello world 6!
message-to-client; Hello world 7!
message-to-client; Hello world 8!
message-to-client; Hello world 9!</pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12060"></a>15.5.2.&nbsp;Asynchronous SSE processing with <code class="literal">EventSource</code></h3></div></div></div><p>
                The main Jersey SSE client API component used to read SSE events asynchronously is <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/EventSource.html" target="_top">EventSource</a>.
                The usage of the <code class="literal">EventSource</code> is shown on the following example.
                </p><div class="example"><a name="sse.ex.client.eventListener"></a><p class="title"><b>Example&nbsp;15.4.&nbsp;Registering <code class="literal">EventListener</code> with <code class="literal">EventSource</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newBuilder()
                        .register(SseFeature.class).build();
WebTarget target = client.target("http://example.com/events");
EventSource eventSource = EventSource.target(target).build();
EventListener listener = new EventListener() {
        @Override
        public void onEvent(InboundEvent inboundEvent) {
            System.out.println(inboundEvent.getName() + "; "
                    + inboundEvent.readData(String.class));
        }
    };
eventSource.register(listener, "message-to-client");
eventSource.open();
...
eventSource.close();</pre></div></div><p><br class="example-break">

                In this example, the client code again connects to the server where the <code class="literal">SseResource</code> from the
                <a class="xref" href="sse.html#example-simple-sse" title="Example&nbsp;15.2.&nbsp;Simple SSE resource method">Example&nbsp;15.2, &#8220;Simple SSE resource method&#8221;</a> is deployed. The <a class="link" href="https://jersey.java.net/apidocs-javax.jax-rs/2.0.1/javax/ws/rs/client/Client.html" target="_top">Client</a> instance
                is again created and initialized with <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/SseFeature.html" target="_top">SseFeature</a>. Then the <a class="link" href="https://jersey.java.net/apidocs-javax.jax-rs/2.0.1/javax/ws/rs/client/WebTarget.html" target="_top">WebTarget</a> is built.
                In this case a request to the web target is not made directly in the code, instead, the web target instance
                is used to initialize a new <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/EventSource.Builder.html" target="_top">EventSource.Builder</a> instance that is used to build a new
                <code class="literal">EventSource</code>. The choice of <code class="literal">build()</code> method is important, as it tells
                the <code class="literal">EventSource.Builder</code> to create a new <code class="literal">EventSource</code> that is not automatically
                connected to the <code class="literal">target</code>. The connection is established only later by manually invoking
                the <code class="literal">eventSource.open()</code> method. A custom <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/EventListener.html" target="_top">EventListener</a>
                implementation is used to listen to and process incoming SSE events. The method readData(Class) says that the
                event data should be de-serialized from a received <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/InboundEvent.html" target="_top">InboundEvent</a> instance into a
                <code class="literal">String</code> Java type. This method call internally executes <a class="link" href="https://jersey.java.net/apidocs-javax.jax-rs/2.0.1/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> which
                de-serializes the event data. This is similar to reading an entity from the <a class="link" href="https://jersey.java.net/apidocs-javax.jax-rs/2.0.1/javax/ws/rs/core/Response.html" target="_top">Response</a> by
                <code class="literal">readEntity(Class)</code>. The method <code class="literal">readData</code> can throw a
                <a class="link" href="https://jersey.java.net/apidocs-javax.jax-rs/2.0.1/javax/ws/rs/ProcessingException.html" target="_top">ProcessingException</a>.
            </p><p>
                The custom event source listener is registered in the event source via
                <code class="literal">EventSource</code><code class="literal">.register(EventListener, String)</code> method. The next method
                arguments define the names of the events to receive and can be omitted. If names are defined, the listener
                will be associated with the named events and will only invoked for events with a name from the set of defined
                event names. It will not be invoked for events with any other name or for events without a name.

                </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                        It is a common mistake to think that unnamed events will be processed by listeners that are registered
                        to process events from a particular name set. That is NOT the case! Unnamed events are only processed
                        by listeners that are not name-bound. The same limitation applied to HTML5 Javascript SSE Client API
                        supported by modern browsers.
                    </p></div><p>

                After a connection to the server is opened by calling the <code class="literal">open()</code> method on the event source,
                the <code class="literal">eventSource</code> starts listening to events. When an event named
                <code class="literal">"message-to-client"</code> comes, the listener will be executed by the event source. If any other
                event comes (with a name different from <code class="literal">"message-to-client"</code>), the registered listener is not
                invoked. Once the client is done with processing and does not want to receive events anymore, it closes the
                connection by calling the <code class="literal">close()</code> method on the event source.
            </p><p>
                The listener from the example above will print the following output:
                </p><pre class="screen">message-to-client; Hello world 0!
message-to-client; Hello world 1!
message-to-client; Hello world 2!
message-to-client; Hello world 3!
message-to-client; Hello world 4!
message-to-client; Hello world 5!
message-to-client; Hello world 6!
message-to-client; Hello world 7!
message-to-client; Hello world 8!
message-to-client; Hello world 9!</pre><p>
            </p><p>
                When browsing through the Jersey SSE API documentation, you may have noticed that the <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/EventSource.html" target="_top">EventSource</a>
                implements <a class="link" href="https://jersey.java.net/apidocs/2.25.1/jersey/org/glassfish/jersey/media/sse/EventListener.html" target="_top">EventListener</a> and provides an empty implementation for the
                <code class="literal">onEvent(InboundEvent inboundEvent)</code> listener method. This adds more flexibility to the
                Jersey client-side SSE API. Instead of defining and registering a separate event listener, in simple scenarios
                you can also choose to derive directly from the <code class="literal">EventSource</code> and override the empty listener
                method to handle the incoming events. This programming model is shown in the following example:

                </p><div class="example"><a name="d0e12188"></a><p class="title"><b>Example&nbsp;15.5.&nbsp;Overriding <code class="literal">EventSource.onEvent(InboundEvent)</code> method</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newBuilder()
                        .register(SseFeature.class).build();
WebTarget target = client.target("http://example.com/events");
EventSource eventSource = new EventSource(target) {
    @Override
    public void onEvent(InboundEvent inboundEvent) {
        if ("message-to-client".equals(inboundEvent.getName())) {
            System.out.println(inboundEvent.getName() + "; "
                    + inboundEvent.readData(String.class));
        }
    }
};
...
eventSource.close();</pre></div></div><p><br class="example-break">

                The code above is very similar to the code in <a class="xref" href="sse.html#sse.ex.client.eventListener" title="Example&nbsp;15.4.&nbsp;Registering EventListener with EventSource">Example&nbsp;15.4, &#8220;Registering <code class="literal">EventListener</code> with <code class="literal">EventSource</code>&#8221;</a>. In this example
                however, the <code class="literal">EventSource</code> is constructed directly using a single-parameter constructor.
                This way, the connection to the SSE endpoint is by default automatically opened at the event source
                creation. The implementation of the <code class="literal">EventListener</code> has been moved into the overridden
                <code class="literal">EventSource.onEvent(...)</code> method. However, this time, the listener method will be executed for
                all events - unnamed as well as with any <code class="literal">name</code>. Therefore the code checks the name whether it is
                an event with the name "message-to-client" that we want to handle. Note that you can still register
                additional <code class="literal">EventListener</code>s later on. The overridden method on the event source allows you to
                handle messages even when no additional listeners are registered yet.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12214"></a>15.5.2.1.&nbsp;<code class="literal">EventSource</code> reconnect support</h4></div></div></div><p>
                    Starting in Jersey 2.3, the <code class="literal">EventSource</code> implementation supports automated recuperation
                    from a connection loss, including negotiation of delivery of any missed events based on the last received
                    SSE event <code class="literal">id</code> field value, provided this field is set by the server and the negotiation
                    facility is supported by the server. In case of a connection loss, the last received SSE event
                    <code class="literal">id</code> field value is send in the <code class="literal">Last-Event-ID</code> HTTP request
                    header as part of a new connection request sent to the SSE endpoint. Upon a receipt of such reconnect request,
                    the SSE endpoint that supports this negotiation facility is expected to replay all missed events.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        Note, that SSE lost event negotiation facility is a best-effort mechanism which does not provide
                        any guaranty that all events would be delivered without a loss. You should therefore not
                        rely on receiving every single event and design your client application code accordingly.
                    </p></div><p>
                    By default, when a connection the the SSE endpoint is lost, the event source will use a default delay
                    before attempting to reconnect to the SSE endpoint. The SSE endpoint can however control the client-side
                    retry delay by including a special <code class="literal">retry</code> field value in any event sent to the client.
                    Jersey <code class="literal">EventSource</code> implementation automatically tracks any received SSE event
                    <code class="literal">retry</code> field values set by the endpoint and adjusts the reconnect delay accordingly,
                    using the last received <code class="literal">retry</code> field value as the new reconnect delay.
                </p><p>
                    In addition to handling the standard connection losses, Jersey <code class="literal">EventSource</code> automatically
                    deals with any <code class="literal">HTTP 503 Service Unavailable</code> responses received from the SSE endpoint,
                    that include a <code class="literal">Retry-After</code> HTTP header with a valid value. The
                    <code class="literal">HTTP 503 + Retry-After</code> technique is often used by HTTP endpoints as a means of
                    connection and traffic throttling. In case a <code class="literal">HTTP 503 + Retry-After</code> response is received
                    in return to a connection request from SSE endpoint, Jersey <code class="literal">EventSource</code> will automatically
                    schedule a reconnect attempt  and use the received <code class="literal">Retry-After</code> HTTP header value as a
                    one-time override of the reconnect delay.
                </p></div></div></div></div><link href="https://jersey.java.net/sh/shCore.css" rel="stylesheet" type="text/css"><link href="https://jersey.java.net/sh/shThemeDefault.css" rel="stylesheet" type="text/css"><script src="https://jersey.java.net/sh/shCore.js" type="text/javascript"></script><script src="https://jersey.java.net/sh/shAutoloader.js" type="text/javascript"></script><script type="text/javascript">
            function path() {
              var args = arguments,
                  result = []
                  ;

              for(var i = 0; i < args.length; i++)
                  result.push(args[i].replace('@', 'https://jersey.java.net/sh/'));

              return result
            };

            SyntaxHighlighter.autoloader.apply(null, path(
              'applescript            @shBrushAppleScript.js',
              'actionscript3 as3      @shBrushAS3.js',
              'bash shell             @shBrushBash.js',
              'coldfusion cf          @shBrushColdFusion.js',
              'cpp c                  @shBrushCpp.js',
              'c# c-sharp csharp      @shBrushCSharp.js',
              'css                    @shBrushCss.js',
              'delphi pascal          @shBrushDelphi.js',
              'diff patch pas         @shBrushDiff.js',
              'erl erlang             @shBrushErlang.js',
              'groovy                 @shBrushGroovy.js',
              'java                   @shBrushJava.js',
              'jfx javafx             @shBrushJavaFX.js',
              'js jscript javascript  @shBrushJScript.js',
              'perl pl                @shBrushPerl.js',
              'php                    @shBrushPhp.js',
              'text plain             @shBrushPlain.js',
              'py python              @shBrushPython.js',
              'ruby rails ror rb      @shBrushRuby.js',
              'sass scss              @shBrushSass.js',
              'scala                  @shBrushScala.js',
              'sql                    @shBrushSql.js',
              'vb vbnet               @shBrushVb.js',
              'xml xhtml xslt html    @shBrushXml.js'
            ));

            SyntaxHighlighter.all();
        </script><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="resource-builder.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="security.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;14.&nbsp;Programmatic API for Building Resources&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;16.&nbsp;Security</td></tr></table></div></div></body></html>