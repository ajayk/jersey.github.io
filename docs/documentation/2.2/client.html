<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;5.&nbsp;Client API</title><link rel="stylesheet" type="text/css" href="/documentation.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"><link rel="home" href="index.html" title="Jersey 2.2 User Guide"><link rel="up" href="index.html" title="Jersey 2.2 User Guide"><link rel="prev" href="deployment.html" title="Chapter&nbsp;4.&nbsp;Deploying a RESTful Web Service"><link rel="next" href="representations.html" title="Chapter&nbsp;6.&nbsp;Representations and Responses"><script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-3160303-1']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script></head><body class="contents"><div class="contents" bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;5.&nbsp;Client API</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="deployment.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="representations.html">Next</a></td></tr></table><hr></div><div style="float:right"><a href="https://jersey.java.net"><img src="https://jersey.java.net/images/jersey_logo.png"></a></div><small>Links:
            <a href="index.html">
                Table of Contents
            </a> | <a href="user-guide.html">
                Single HTML
            </a></small><div lang="en" class="chapter" title="Chapter&nbsp;5.&nbsp;Client API"><div class="titlepage"><div><div><h2 class="title"><a name="client"></a>Chapter&nbsp;5.&nbsp;Client API</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="client.html#d0e2323">5.1. Uniform Interface Constraint</a></span></dt><dt><span class="section"><a href="client.html#d0e2366">5.2. Ease of use and reusing JAX-RS artifacts</a></span></dt><dt><span class="section"><a href="client.html#d0e2482">5.3. Overview of the Client API</a></span></dt><dd><dl><dt><span class="section"><a href="client.html#d0e2485">5.3.1. Getting started with the client API</a></span></dt><dt><span class="section"><a href="client.html#d0e2504">5.3.2. 
                Creating and configuring a Client instance
            </a></span></dt><dt><span class="section"><a href="client.html#d0e2688">5.3.3. Targeting a web resource</a></span></dt><dt><span class="section"><a href="client.html#d0e2756">5.3.4. Identifying resource on WebTarget</a></span></dt><dt><span class="section"><a href="client.html#d0e2832">5.3.5. Invoking a HTTP request</a></span></dt><dt><span class="section"><a href="client.html#d0e2975">5.3.6. Example summary</a></span></dt></dl></dd><dt><span class="section"><a href="client.html#d0e3004">5.4. Java instances and types for representations</a></span></dt><dd><dl><dt><span class="section"><a href="client.html#d0e3023">5.4.1. Adding support for new representations</a></span></dt></dl></dd><dt><span class="section"><a href="client.html#d0e3057">5.5. Client Transport Connectors</a></span></dt><dt><span class="section"><a href="client.html#d0e3131">5.6. Using client request and response filters</a></span></dt><dt><span class="section"><a href="client.html#d0e3165">5.7. Closing connections</a></span></dt><dt><span class="section"><a href="client.html#d0e3189">5.8. Securing a Client</a></span></dt><dd><dl><dt><span class="section"><a href="client.html#d0e3300">5.8.1. HTTP Basic Authentication Support</a></span></dt></dl></dd></dl></div><p>
        This section introduces the JAX-RS Client API, which is a fluent Java based API for communication with RESTful Web
        services. This standard API that is also part of Java EE 7 is designed to make it very easy to consume a Web service
        exposed via HTTP protocol and enables developers to concisely and efficiently implement portable client-side solutions
        that leverage existing and well established client-side HTTP connector implementations.
    </p><p>
        The JAX-RS client API can be utilized to consume any Web service exposed on top of a HTTP protocol or it's
        extension (e.g. WebDAV), and is not restricted to services implemented using JAX-RS. Yet, developers familiar with JAX-RS
        should find the client API complementary to their services, especially if the client API is utilized by those services
        themselves, or to test those services.
        The JAX-RS client API finds inspiration in the proprietary Jersey 1.x Client API and developers familiar with the Jersey
        1.x Client API should find it easy to understand all the concepts introduced in the new JAX-RS Client API.
    </p><p>
        The goals of the client API are threefold:

        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    Encapsulate a key constraint of the REST architectural style, namely the Uniform Interface Constraint and
                    associated data elements, as client-side Java artifacts;
                </p></li><li class="listitem"><p>
                    Make it as easy to consume RESTful Web services exposed over HTTP, same as the JAX-RS server-side API makes
                    it easy to develop RESTful Web services; and
                </p></li><li class="listitem"><p>
                    Share common concepts and extensibility points of the JAX-RS API between the server and the client side
                    programming models.
                </p></li></ol></div><p>

        As an extension to the standard JAX-RS Client API, the  Jersey Client API supports a pluggable architecture to enable the
        use of different underlying HTTP client <a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/client/spi/Connector.html" target="_top">Connector</a> implementations. Several such implementations are
        currently provided with Jersey. We have a default client connector using <code class="literal">Http(s)URLConnection</code> supplied
        with the JDK as well as connector implementations based on Apache HTTP Client, and Grizzly Asynchronous Client.
    </p><div class="section" title="5.1.&nbsp;Uniform Interface Constraint"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2323"></a>5.1.&nbsp;Uniform Interface Constraint</h2></div></div></div><p>
            The uniform interface constraint bounds the architecture of RESTful Web services so that a client, such
            as a browser, can utilize the same interface to communicate with any service. This is a very powerful concept
            in software engineering that makes Web-based search engines and service mash-ups possible. It induces properties
            such as:

            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>simplicity, the architecture is easier to understand and maintain; and</p></li><li class="listitem"><p>
                        evolvability or loose coupling, clients and services can evolve over time perhaps in new and
                        unexpected ways, while retaining backwards compatibility.
                    </p></li></ol></div><p>

            Further constraints are required:

            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>every resource is identified by a URI;</p></li><li class="listitem"><p>
                        a client interacts with the resource via HTTP requests and responses using a fixed set of
                        HTTP methods;
                    </p></li><li class="listitem"><p>one or more representations can be returned and are identified by media types; and</p></li><li class="listitem"><p>the contents of which can link to further resources.</p></li></ol></div><p>

            The above process repeated over and again should be familiar to anyone who has used a browser to fill
            in HTML forms and follow links. That same process is applicable to non-browser based clients.
        </p><p>
            Many existing Java-based client APIs, such as the Apache HTTP client API or <code class="literal">HttpUrlConnection</code>
            supplied with the JDK place too much focus on the Client-Server constraint for the exchanges of request and
            responses rather than a resource, identified by a URI, and the use of a fixed set of HTTP methods.
        </p><p>A resource in the JAX-RS client API is an instance of the Java class
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/WebTarget.html" target="_top">WebTarget</a>.
            and encapsulates an URI. The fixed set of HTTP methods can be invoked based on the
            <code class="literal">WebTarget</code>.
            The representations are Java types, instances of which, may contain links that new instances of
            <code class="literal">WebTarget</code> may be created from.
        </p></div><div class="section" title="5.2.&nbsp;Ease of use and reusing JAX-RS artifacts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2366"></a>5.2.&nbsp;Ease of use and reusing JAX-RS artifacts</h2></div></div></div><p>
            Since a JAX-RS component is represented as an annotated Java type, it makes it easy to configure, pass around and
            inject in ways that are not so intuitive or possible with other client-side APIs.
            The Jersey Client API reuses many aspects of the JAX-RS and the Jersey implementation such as:
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                        URI building using <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/UriBuilder.html" target="_top">UriBuilder</a> and <a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/uri/UriTemplate.html" target="_top">UriTemplate</a> to safely build URIs;
                    </p></li><li class="listitem"><p>Built-in support for Java types of representations such as
                        <code class="literal">byte[]</code>,
                        <code class="literal">String</code>,
                        <code class="literal">Number</code>,
                        <code class="literal">Boolean</code>,
                        <code class="literal">Character</code>,
                        <code class="literal">InputStream</code>,
                        <code class="literal">java.io.Reader</code>,
                        <code class="literal">File</code>,
                        <code class="literal">DataSource</code>,
                        JAXB beans as well as additional Jersey-specific JSON and <a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/media/multipart/package-info.html" target="_top">Multi Part</a> support.
                    </p></li><li class="listitem"><p>Using the fluent builder-style API pattern to make it easier to construct requests.</p></li></ol></div><p>
            Some APIs, like the Apache HTTP Client or <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/net/HttpURLConnection.html" target="_top">HttpURLConnection</a>
            can be rather hard to use and/or require too much code to do something relatively simple, especially when
            the client needs to understand different payload representations.
            This is why the Jersey implementation of JAX-RS Client API provides support for wrapping <code class="literal">HttpUrlConnection</code>
            and the Apache HTTP client. Thus it is possible to get the benefits of the established JAX-RS implementations and
            features while getting the ease of use benefit of the simple design of the JAX-RS client API.
            For example, with a low-level HTTP client library, sending a POST request with a bunch of typed HTML form parameters
            and receiving a response de-serialized into a JAXB bean is not straightforward at all. With the new JAX-RS Client API
            supported by Jersey this task is very easy:

            </p><div class="example"><a name="client.ex.formpost"></a><p class="title"><b>Example&nbsp;5.1.&nbsp;POST request with form parameters</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newClient();
WebTarget target = client.target("http://localhost:9998").path("resource");

Form form = new Form();
form.param("x", "foo");
form.param("y", "bar");

MyJAXBBean bean =
target.request(MediaType.APPLICATION_JSON_TYPE)
    .post(Entity.entity(form,MediaType.APPLICATION_FORM_URLENCODED_TYPE),
        MyJAXBBean.class);</pre></div></div><p><br class="example-break">

            In the <a class="xref" href="client.html#client.ex.formpost" title="Example&nbsp;5.1.&nbsp;POST request with form parameters">Example&nbsp;5.1, &#8220;POST request with form parameters&#8221;</a> a new <code class="literal">WebTarget</code> instance is created using a new
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/Client.html" target="_top">Client</a> instance first, next a <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Form.html" target="_top">Form</a> instance is created with two form parameters.
            Once ready, the <code class="literal">Form</code> instance is <code class="literal">POST</code>ed to the target resource.
            First, the acceptable media type is specified in the <code class="literal">request(...)</code> method. Then in the
            <code class="literal">post(...)</code> method, a call to a static method on JAX-RS <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/Entity.html" target="_top">Entity</a> is made to construct
            the request entity instance and attach the proper content media type to the form entity that is being sent. The
            second parameter in the <code class="literal">post(...)</code> method specifies the Java type of the response entity that should
            be returned from the method in case of a successful response. In this case an instance of JAXB bean is requested to
            be returned on success. The Jersey client API takes care of selecting the proper <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> for
            the serialization of the <code class="literal">Form</code> instance, invoking the <code class="literal">POST</code> request and producing and
            de-serialization of the response message payload into an instance of a JAXB bean using a proper
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a>.
        </p><p>If the code above had to be written using <code class="literal">HttpUrlConnection</code>, the developer would have to write custom
            code to serialize the form data that are sent within the POST request and de-serialize the response input stream
            into a JAXB bean. Additionally, more code would have to be written to make it easy to reuse the logic when
            communicating with the same resource <code class="literal">&#8220;http://localhost:8080/resource&#8221;</code> that is represented by
            the JAX-RS <code class="literal">WebTarget</code> instance in our example.
        </p></div><div class="section" title="5.3.&nbsp;Overview of the Client API"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2482"></a>5.3.&nbsp;Overview of the Client API</h2></div></div></div><div class="section" title="5.3.1.&nbsp;Getting started with the client API"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2485"></a>5.3.1.&nbsp;Getting started with the client API</h3></div></div></div><p>
                Refer to the <a class="link" href="modules-and-dependencies.html#dependencies" title="2.3.&nbsp;Common Jersey Use Cases">dependencies</a> for details on the dependencies when using the
                Jersey JAX-RS Client support.
            </p><p>
                You may also want to use a custom <a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/client/spi/Connector.html" target="_top">Connector</a> implementation. In such case you would need to include
                additional dependencies on the module(s) containing the custom client connector that you want to use. See section
                <a class="link" href="client.html#connectors">"Configuring custom Connectors"</a> about how to use and configure a custom
                Jersey client transport <code class="literal">Connector</code>.</p></div><div class="section" title="5.3.2.&nbsp; Creating and configuring a Client instance"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2504"></a>5.3.2.&nbsp;
                Creating and configuring a Client instance
            </h3></div></div></div><p>
                JAX-RS Client API is a designed to allow fluent programming model. This means, a construction of a
                <code class="literal">Client</code> instance, from which a <code class="literal">WebTarget</code> is created, from which a
                request <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/Invocation.html" target="_top">Invocation</a> is built and invoked can be chained in a single "flow" of invocations.
                The individual steps of the flow will be shown in the following sections.
                To utilize the client API it is first necessary to build an instance of a
                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/Client.html" target="_top">Client</a> using one of the static <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/ClientBuilder.html" target="_top">ClientBuilder</a> factory methods. Here's the most
                simple example:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newClient();</pre><p>

                The <code class="literal">ClientBuilder</code> is a JAX-RS API used to create new instances of <code class="literal">Client</code>.
                In a slightly more advanced scenarios, <code class="literal">ClientBuilder</code> can be used to configure additional
                client instance properties, such as a SSL transport settings, if needed (see <a class="xref" href="">???</a>
                below).
            </p><p>
                A <code class="literal">Client</code> instance can be configured during creation by passing a <a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/client/ClientConfig.html" target="_top">ClientConfig</a>
                to the <code class="literal">newClient(Configurable)</code> <code class="literal">ClientBuilder</code> factory method.
                <a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/client/ClientConfig.html" target="_top">ClientConfig</a> implements <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configurable.html" target="_top">Configurable</a> and therefore it offers methods to register
                providers (e.g. features or individual entity providers, filters or interceptors) and setup properties.
                The following code shows a registration of custom client filters:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientConfig clientConfig = new ClientConfig();
clientConfig.register(MyClientResponseFilter.class);
clientConfig.register(new AnotherClientFilter());
Client client = ClientBuilder.newClient(clientConfig);</pre><p>

                In the example, filters are registered using the <code class="literal">ClientConfig.register(...)</code> method. There are
                multiple overloaded versions of the method that support registration of feature and provider classes or instances.
                Once a <code class="literal">ClientConfig</code> instance is configured, it can be passed to the
                <code class="literal">ClientBuilder</code> to create a pre-configured <code class="literal">Client</code> instance.
            </p><p>
                Note that the Jersey <code class="literal">ClientConfig</code> supports the fluent API model of <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configurable.html" target="_top">Configurable</a>.
                With that the code that configures a new client instance can be also written using a more compact style as shown
                below.

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
Client client = ClientBuilder.newClient(new ClientConfig()
        .register(MyClientResponseFilter.class)
        .register(new AnotherClientFilter());</pre><p>

                The ability to leverage this compact pattern is inherent to all JAX-RS and Jersey Client API components.
            </p><p>
                Since <code class="literal">Client</code> implements <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configurable.html" target="_top">Configurable</a> interface too, it can be configured further
                even after it has been created. Important is to mention that any configuration change done on a
                <code class="literal">Client</code> instance will not influence the <a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/client/ClientConfig.html" target="_top">ClientConfig</a> instance that was used to
                provide the initial <code class="literal">Client</code> instance configuration at the instance creation time.
                The next piece of code shows a configuration of an existing <code class="literal">Client</code> instance.

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">client.register(ThirdClientFilter.class);</pre><p>

                Similarly to earlier examples, since <code class="literal">Client.register(...)</code> method supports the fluent API style,
                multiple client instance configuration calls can be chained:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">client.register(FilterA.class)
      .register(new FilterB())
      .property("my-property", true);</pre><p>

                To get the current configuration of the <code class="literal">Client</code> instance a <code class="literal">getConfiguration()</code>
                method can be used.

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientConfig clientConfig = new ClientConfig();
clientConfig.register(MyClientResponseFilter.class);
clientConfig.register(new AnotherClientFilter());
Client client = ClientBuilder.newClient(clientConfig);
client.register(ThirdClientFilter.class);
Configuration newConfiguration = client.getConfiguration();</pre><p>

                In the code, an additional <code class="literal">MyClientResponseFilter</code> class and
                <code class="literal">AnotherClientFilter</code> instance are registered in the <code class="literal">clientConfig</code>. The
                <code class="literal">clientConfig</code> is then used to construct a new <code class="literal">Client</code> instance. The
                <code class="literal">ThirdClientFilter</code> is added separately to the constructed <code class="literal">Client</code> instance.
                This does not influence the configuration represented by the original <code class="literal">clientConfig</code>.
                In the last step a <code class="literal">newConfiguration</code> is retrieved from the <code class="literal">client</code>. This
                configuration contains all three registered filters while the original <code class="literal">clientConfig</code> instance
                still contains only two filters. Unlike <code class="literal">clientConfig</code> created separately, the
                <code class="literal">newConfiguration</code> retrieved from the <code class="literal">client</code> instance represents a live
                client configuration view. Any additional configuration changes made to the <code class="literal">client</code> instance
                are also reflected in the <code class="literal">newConfiguration</code>. So, <code class="literal">newConfiguration</code> is really
                a view of the <code class="literal">client</code> configuration and not a configuration state copy. These principles are
                important in the client API and will be used in the following sections too. For example, you can construct a
                common base configuration for all clients (in our case it would be <code class="literal">clientConfig</code>) and
                then reuse this common configuration instance to configure multiple <code class="literal">client</code> instances that can
                be further specialized. Similarly, you can use an existing <code class="literal">client</code> instance configuration to
                configure another client instance without having to worry about any side effects in the original
                <code class="literal">client</code> instance.
            </p></div><div class="section" title="5.3.3.&nbsp;Targeting a web resource"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2688"></a>5.3.3.&nbsp;Targeting a web resource</h3></div></div></div><p>
                Once you have a <code class="literal">Client</code> instance you can create a <code class="literal">WebTarget</code> from it.

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">WebTarget webTarget = client.target("http://example.com/rest");</pre><p>

                A <code class="literal">Client</code> contains several <code class="literal">target(...)</code> methods that allow for creation of
                <code class="literal">WebTarget</code> instance. In this case we're using <code class="literal">target(String uri)</code> version.
                The <code class="literal">uri</code> passed to the method as a <code class="literal">String</code> is the URI of the targeted
                web resource. In more complex scenarios it could be the context root URI of the whole RESTful application, from
                which <code class="literal">WebTarget</code> instances representing individual resource targets can be derived and
                individually configured. This is possible, because JAX-RS <code class="literal">WebTarget</code> also implements
                <code class="literal">Configurable</code>:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">WebTarget webTarget = client.target("http://example.com/rest");
webTarget.register(FilterForExampleCom.class);</pre><p>

                The configuration principles used in JAX-RS client API apply to <code class="literal">WebTarget</code> as well. Each
                <code class="literal">WebTarget</code> instance inherits a configuration from it's parent (either a client or another
                web target) and can be further custom-configured without affecting the configuration of the parent component.
                In this case, the <code class="literal">FilterForExampleCom</code> will be registered only in the
                <code class="literal">webTarget</code> and not in <code class="literal">client</code>. So, the <code class="literal">client</code>
                can still be used to create new <code class="literal">WebTarget</code> instances pointing at other URIs using just the
                common client configuration, which <code class="literal">FilterForExampleCom</code> filter is not part of.
            </p></div><div class="section" title="5.3.4.&nbsp;Identifying resource on WebTarget"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2756"></a>5.3.4.&nbsp;Identifying resource on WebTarget</h3></div></div></div><p>
                Let's assume we have a <code class="literal">webTarget</code> pointing at <code class="literal">"http://example.com/rest"</code> URI
                that represents a context root of a RESTful application and there is a resource exposed on the URI
                <code class="literal">"http://example.com/rest/resource"</code>. As already mentioned, a <code class="literal">WebTarget</code>
                instance can be used to derive other web targets. Use the following code to define a path to the resource.
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">WebTarget resourceWebTarget = webTarget.path("resource");</pre><p>

                The <code class="literal">resourceWebTarget</code> now points to the resource on URI
                <code class="literal">"http://example.com/rest/resource"</code>. Again if we configure the
                <code class="literal">resourceWebTarget</code> with a filter specific to the <code class="literal">resource</code>,
                it will not influence the original <code class="literal">webTarget</code> instance. However, the filter
                <code class="literal">FilterForExampleCom</code> registration will still be inherited by the
                <code class="literal">resourceWebTarget</code> as it has been created from <code class="literal">webTarget</code>. This mechanism
                allows you to share the common configuration of related resources (typically hosted under the same URI root,
                in our case represented by the <code class="literal">webTarget</code> instance), while allowing for further configuration
                specialization based on the specific requirements of each individual resource. The same configuration principles
                of inheritance (to allow common config propagation) and decoupling (to allow individual config customization)
                applies to all components in JAX-RS Client API discussed below.
            </p><p>
                Let's say there is a sub resource on the path <code class="literal">"http://example.com/rest/resource/helloworld"</code>.
                You can derive a <code class="literal">WebTarget</code> for this resource simply by:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">WebTarget helloworldWebTarget = resourceWebTarget.path("helloworld");</pre><p>

                Let's assume that the <code class="literal">helloworld</code> resource accepts a query param for <code class="literal">GET</code>
                requests which defines the greeting message. The next code snippet shows a code that creates
                a new <code class="literal">WebTarget</code> with the query param defined.

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">WebTarget helloworldWebTargetWithQueryParam =
        helloworldWebTarget.queryParam("greeting", "Hi World!");</pre><p>

                Please note that apart from methods that can derive new <code class="literal">WebTarget</code> instance based on a URI path
                or query parameters, the JAX-RS <code class="literal">WebTarget</code> API contains also methods for working with matrix
                parameters too.
            </p></div><div class="section" title="5.3.5.&nbsp;Invoking a HTTP request"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2832"></a>5.3.5.&nbsp;Invoking a HTTP request</h3></div></div></div><p>
                Let's now focus on invoking a <code class="literal">GET</code> HTTP request on the created web targets. To start building a new
                HTTP request invocation, we need to create a new <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/Invocation.Builder.html" target="_top">Invocation.Builder</a>.

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Invocation.Builder invocationBuilder =
        helloworldWebTargetWithQueryParam.request(MediaType.TEXT_PLAIN_TYPE);
invocationBuilder.header("some-header", "true");</pre><p>

                A new invocation builder instance is created using one of the <code class="literal">request(...)</code> methods that are
                available on <code class="literal">WebTarget</code>. A couple of these methods accept parameters that let you define
                the media type of the representation requested to be returned from the resource. Here we are saying that we
                request a <code class="literal">"text/plain"</code> type. This tells Jersey to add a <code class="literal">Accept: text/plain</code>
                HTTP header to our request.
            </p><p>
                The <code class="literal">invocationBuilder</code> is used to setup request specific parameters. Here we can setup headers
                for the request or for example cookie parameters. In our example we set up a <code class="literal">"some-header"</code>
                header to value <code class="literal">true</code>.
            </p><p>
                Once finished with request customizations, it's time to invoke the request. We have two options now.
                We can use the <code class="literal">Invocation.Builder</code> to build a generic <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/Invocation.html" target="_top">Invocation</a> instance
                that will be invoked some time later. Using <code class="literal">Invocation</code> we will be able to e.g. set additional
                request properties which are properties in a batch of several requests and use the generic JAX-RS
                <code class="literal">Invocation</code> API to invoke the batch of requests without actually knowing all the details
                (such as request HTTP method, configuration etc.). Any properties set on an invocation instance can be read
                during the request processing. For example, in a custom <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/RequestFilter.html" target="_top">ClientRequestFilter</a> you can call
                <code class="literal">getProperty()</code> method on the supplied <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/ClientRequestContext.html" target="_top">ClientRequestContext</a> to read a request
                property. Note that these request properties are different from the configuration properties set on
                <code class="literal">Configurable</code>. As mentioned earlier, an <code class="literal">Invocation</code> instance provides generic
                invocation API to invoke the HTTP request it represents either synchronously or asynchronously. See
                the <a class="xref" href="async.html" title="Chapter&nbsp;10.&nbsp;Asynchronous Services and Clients">Chapter&nbsp;10, <i>Asynchronous Services and Clients</i></a> for more information on asynchronous invocations.
            </p><p>
                In case you do not want to do any batch processing on your HTTP request invocations prior to invoking them, there
                is another, more convenient approach that you can use to invoke your requests directly from an
                <code class="literal">Invocation.Builder</code> instance. This approach is demonstrated in the next Java code listing.
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Response response = invocationBuilder.get();</pre><p>

                While short, the code in the example performs multiple actions. First, it will build the the request from the
                <code class="literal">invocationBuilder</code>. The URI of request will be
                <code class="literal">http://example.com/rest/resource/helloworld?greeting="Hi%20World!"</code> and the request will contain
                <code class="literal">some-header: true</code> and <code class="literal">Accept: text/plain</code> headers. The request will then pass
                trough all configured request filters ( <code class="literal">AnotherClientFilter</code>,
                <code class="literal">ThirdClientFilter</code> and
                <code class="literal">FilterForExampleCom</code>). Once processed by the filters, the request will be sent to the remote
                resource. Let's say the resource then returns an HTTP 200 message with a plain text response content that contains
                the value sent in the request <code class="literal">greeting</code> query parameter. Now we can observe the returned
                response:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">System.out.println(response.getStatus());
System.out.println(response.readEntity(String.class));</pre><p>

                which will produce the following output to the console:

                </p><pre class="screen">200
Hi World!</pre><p>

                As we can see, the request was successfully processed (code 200) and returned an entity (representation) is
                <code class="literal">"Hi World!"</code>. Note that since ve have configured a <code class="literal">MyClientResponseFilter</code>
                in the resource target, when <code class="literal">response.readEntity(String.class)</code> gets called, the response
                returned from the remote endpoint is passed through the response filter chain (including the
                <code class="literal">MyClientResponseFilter</code>) and entity interceptor chain and at last a proper
                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> is located to read the response content bytes from the response stream into a
                Java <code class="literal">String</code> instance. Check <a class="xref" href="filters-and-interceptors.html" title="Chapter&nbsp;9.&nbsp;Filters and Interceptors">Chapter&nbsp;9, <i>Filters and Interceptors</i></a> to lear more about
                request and response filters and entity interceptors.
            </p><p>
                Imagine now that you would like to invoke a <code class="literal">POST</code> request but without any query parameters. You would
                just use the <code class="literal">helloworldWebTarget</code> instance created earlier and call the
                <code class="literal">post()</code> instead of <code class="literal">get()</code>.
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Response postResponse =
        helloworldWebTarget.request(MediaType.TEXT_PLAIN_TYPE)
                .post(Entity.entity("A string entity to be POSTed", MediaType.TEXT_PLAIN));</pre><p>
            </p></div><div class="section" title="5.3.6.&nbsp;Example summary"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2975"></a>5.3.6.&nbsp;Example summary</h3></div></div></div><p>
                The following code puts together the pieces used in the earlier examples.

                </p><div class="example"><a name="d0e2980"></a><p class="title"><b>Example&nbsp;5.2.&nbsp;Using JAX-RS Client API</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientConfig clientConfig = new ClientConfig();
clientConfig.register(MyClientResponseFilter.class);
clientConfig.register(new AnotherClientFilter());

Client client = ClientBuilder.newClient(clientConfig);
client.register(ThirdClientFilter.class);

WebTarget webTarget = client.target("http://example.com/rest");
webTarget.register(FilterForExampleCom.class);
WebTarget resourceWebTarget = webTarget.path("resource");
WebTarget helloworldWebTarget = resourceWebTarget.path("helloworld");
WebTarget helloworldWebTargetWithQueryParam =
        helloworldWebTarget.queryParam("greeting", "Hi World!");

Invocation.Builder invocationBuilder =
        helloworldWebTargetWithQueryParam.request(MediaType.TEXT_PLAIN_TYPE);
invocationBuilder.header("some-header", "true");

Response response = invocationBuilder.get();
System.out.println(response.getStatus());
System.out.println(response.readEntity(String.class));</pre></div></div><p><br class="example-break">

                Now we can try to leverage the fluent API style to write this code in a more compact way.

                </p><div class="example"><a name="d0e2986"></a><p class="title"><b>Example&nbsp;5.3.&nbsp;Using JAX-RS Client API fluently</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newClient(new ClientConfig()
            .register(MyClientResponseFilter.class)
            .register(new AnotherClientFilter()));

String entity = client.target("http://example.com/rest")
            .register(FilterForExampleCom.class)
            .path("resource/helloworld")
            .queryParam("greeting", "Hi World!")
            .request(MediaType.TEXT_PLAIN_TYPE)
            .header("some-header", "true")
            .get(String.class);</pre></div></div><p><br class="example-break">

                The code above does the same thing except it skips the generic <code class="literal">Response</code> processing and directly
                requests an entity in the last <code class="literal">get(String.class)</code> method call. This shortcut method let's you
                specify that (in case the response was returned successfully with a HTTP 2xx status code) the response entity
                should be returned as Java <code class="literal">String</code> type. This compact example demonstrates another advantage of
                the JAX-RS client API. The fluency of JAX-RS Client API is convenient especially with simple use cases.
                Here is another a very simple GET request returning a String representation (entity):

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">String responseEntity = ClientBuilder.newClient()
            .target("http://example.com").path("resource/rest")
                        .request().get(String.class);</pre><p>
            </p></div></div><div class="section" title="5.4.&nbsp;Java instances and types for representations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3004"></a>5.4.&nbsp;Java instances and types for representations</h2></div></div></div><p>
            All the Java types and representations supported by default on the Jersey server side for
            requests and responses are also supported on the client side.
            For example, to process a response entity (or representation) as a stream of bytes use InputStream as follows:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">InputStream in = response.readEntity(InputStream.class);

... // Read from the stream

in.close();
            </pre><p>

            Note that it is important to close the stream after processing so that resources are freed up.
        </p><p>
            To <code class="literal">POST</code> a file use a <code class="literal">File</code> instance as follows:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">File f = ...

...

webTarget.request().post(Entity.entity(f, MediaType.TEXT_PLAIN_TYPE));
            </pre><p>
        </p><div class="section" title="5.4.1.&nbsp;Adding support for new representations"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3023"></a>5.4.1.&nbsp;Adding support for new representations</h3></div></div></div><p>
                The support for new application-defined representations as Java types requires the
                implementation of the same JAX-RS entity provider extension interfaces as for the server side JAX-RS API, namely
                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> and <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a>
                respectively, for request and response entities (or inbound and outbound representations).
            </p><p>
                Classes or implementations of the provider-based interfaces need to be registered as providers within the
                JAX-RS or Jersey Client API components that implement <code class="literal">Configurable</code> contract
                (<code class="literal">ClientBuilder</code>, <code class="literal">Client</code>, <code class="literal">WebTarget</code> or
                <code class="literal">ClientConfig</code>), as was shown in the earlier sections.
                Some media types are provided in the form of JAX-RS <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Feature.html" target="_top">Feature</a> a concept that allows the extension
                providers to group together multiple different extension providers and/or configuration properties in order
                to simplify the registration and configuration of the provided feature by the end users. For example,
                <a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/moxy/json/MoxyJsonFeature.html" target="_top">MoxyJsonFeature</a> can be register to enable and configure JSON binding support via MOXy
                library.
            </p></div></div><div class="section" title="5.5.&nbsp;Client Transport Connectors"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3057"></a>5.5.&nbsp;<a name="connectors"></a>Client Transport Connectors</h2></div></div></div><p>
            By default, the transport layer in Jersey is provided by <code class="literal">HttpUrlConnection</code>. This transport is implemented
            in Jersey via <a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/client/HttpUrlConnector.html" target="_top">HttpUrlConnector</a> that implements Jersey-specific <a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/client/spi/Connector.html" target="_top">Connector</a> SPI.
            You can implement and/or register your own <code class="literal">Connector</code> instance to the Jersey
            <code class="literal">Client</code> implementation, that will replace the default <code class="literal">HttpUrlConnection</code>-based
            transport layer. Jersey provides several alternative client transport connector implementations that are ready-to-use.
            You can use <a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/apache/ApacheConnector.html" target="_top">ApacheConnector</a> (add a maven dependency to
            <code class="literal">org.glassfish.jersey.connectors:jersey-apache-connector</code>)
            or <a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/grizzly/GrizzlyConnector.html" target="_top">GrizzlyConnector</a> (add a maven dependency to
            <code class="literal">org.glassfish.jersey.connectors:jersey-grizzly-connector</code>) alternatively. Please, note again, that
            the <a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/client/spi/Connector.html" target="_top">Connector</a> SPI is not a feature of JAX-RS but is a Jersey-specific extension API that will only
            work with Jersey. Following example shows how to setup the custom <code class="literal">Connector</code> to the Jersey client.

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientConfig clientConfig = new ClientConfig();
Connector connector = new GrizzlyConnector(clientConfig);
clientConfig.connector(connector);
Client client = ClientBuilder.newClient(clientConfig);</pre><p>

            <code class="literal">Client</code> accepts as as a constructor argument a <code class="literal">Configurable</code> instance. Jersey
            implementation of the <code class="literal">Configurable</code> provider for the client is <code class="literal">ClientConfig</code>.
            By using the Jersey <code class="literal">ClientConfig</code> you can configure the custom <code class="literal">Connector</code>
            into the <code class="literal">ClientConfig</code>. The <code class="literal">GrizzlyConnector</code> is used as a custom connector
            in the example above. Please note that the connector cannot be registered as a provider
            using <code class="literal">Configurable</code><code class="literal">.register(...)</code> at the moment.
        </p></div><div class="section" title="5.6.&nbsp;Using client request and response filters"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3131"></a>5.6.&nbsp;Using client request and response filters</h2></div></div></div><p>
            Filtering requests and responses can provide useful lower-level concept focused on a certain independent aspect or
            domain that is decoupled from the application layer of building and sending requests, and processing responses.
            Filters can read/modify the request URI, headers and entity or read/modify the response status, headers and entity.
        </p><p>
            Jersey contains the following useful client-side filters that you may want to use in your applications:

            </p><table border="0" summary="Simple list" class="simplelist"><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/client/filter/CsrfProtectionFilter.html" target="_top">CsrfProtectionFilter</a>: Cross-site request forgery protection filter (adds
                    <code class="literal">X-Requested-By</code> to each state changing request).</td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/client/filter/EncodingFeature.html" target="_top">EncodingFeature</a>: Feature that registers encoding filter which use registered
                    <a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/common/spi/ContentEncoder.html" target="_top">ContentEncoder</a>s to encode and decode the communication. The encoding/decoding is performed
                    in interceptor (you don't need to register this interceptor). Check the javadoc of the
                    <a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/client/filter/EncodingFeature.html" target="_top">EncodingFeature</a> in order to use it.</td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/client/filter/HttpBasicAuthFilter.html" target="_top">HttpBasicAuthFilter</a>: HTTP Basic Authentication filter (see <a class="xref" href="">???</a>
                    below).</td></tr></table><p>

            Note that these features are provided by Jersey, but since they use and implement JAX-RS API, the features should
            be portable and run in any JAX-RS implementation, not just Jersey. See <a class="xref" href="filters-and-interceptors.html" title="Chapter&nbsp;9.&nbsp;Filters and Interceptors">Chapter&nbsp;9, <i>Filters and Interceptors</i></a>
            chapter for more information on filters and interceptors.
        </p></div><div class="section" title="5.7.&nbsp;Closing connections"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3165"></a>5.7.&nbsp;Closing connections</h2></div></div></div><p>
            The underlying connections are opened for each request
            and closed after the response is received and entity is processed (entity is read). See the
            following example:
        </p><div class="example"><a name="d0e3170"></a><p class="title"><b>Example&nbsp;5.4.&nbsp;Closing connections</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final WebTarget target = ... some web target
Response response = target.path("resource").request().get();
System.out.println("Connection is still open.");
System.out.println("string response: " + response.readEntity(String.class));
System.out.println("Now the connection is closed.");</pre></div></div><br class="example-break"><p>
            If you don't read the entity, then you need to close the response manually by
            <code class="literal">response.close()</code>. Also if the entity is read into an <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/io/InputStream.html" target="_top">InputStream</a>
            (by <code class="literal">response.readEntity(InputStream.class)</code>), the connection stays open until
            you finish reading from the <code class="literal">InputStream</code>. In that case, the InputStream
            or the Response should be closed manually at the end of reading from InputStream.
        </p></div><div class="section" title="5.8.&nbsp;Securing a Client"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3189"></a>5.8.&nbsp;Securing a Client</h2></div></div></div><p>
            This section describes how to setup SSL configuration on Jersey client (using JAX-RS API). The SSL configuration is
            setup in <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/ClientBuilder.html" target="_top">ClientBuilder</a>. The client builder contains methods for definition of <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/security/KeyStore.html" target="_top">KeyStore</a>,
            <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/security/TrustStore.html" target="_top">TrustStore</a> or entire <a class="link" href="http://docs.oracle.com/javase/6/docs/api/javax/net/ssl/SslContext.html" target="_top">SslContext</a>. See the following example:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">SSLContext ssl = ... your configured SSL context;
Client client = ClientBuilder.newBuilder().sslContext(ssl).build();
Response response = client.target("https://example.com/resource").request().get();</pre><p>

            The example above shows how to setup a custom <code class="literal">SslContext</code> to the <code class="literal">ClientBuilder</code>.
            Creating a <code class="literal">SslContext</code> can be more difficult as you might need to init instance properly with the protocol,
            <code class="literal">KeyStore</code>, <code class="literal">TrustStore</code>, etc. Jersey offers a utility <a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/SslConfigurator.html" target="_top">ClientConfig</a> class that
            can be used to setup the <code class="literal">SslContext</code>. The <code class="literal">SslConfigurator</code> can be configured based on
            standardized system properties for SSL configuration, so for example you can configure the <code class="literal">KeyStore</code> file
            name using a environment variable <code class="literal">javax.net.ssl.keyStore</code> and <code class="literal">SslConfigurator</code>
            will use such a variable to setup the <code class="literal">SslContext</code>. See javadoc of <a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/SslConfigurator.html" target="_top">ClientConfig</a> for more
            details. The following code shows how a <code class="literal">SslConfigurator</code> can be used to create a custom SSL
            context.

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">SslConfigurator sslConfig = SslConfigurator.newInstance()
        .trustStoreFile("./truststore_client")
        .trustStorePassword("secret-password-for-truststore")
        .keyStoreFile("./keystore_client")
        .keyPassword("secret-password-for-keystore");

SSLContext sslContext = sslConfig.createSSLContext();
Client client = ClientBuilder.newBuilder().sslContext(sslContext).build();</pre><p>
        </p><p>
            Note that you can also setup <code class="literal">KeyStore</code> and <code class="literal">TrustStore</code> directly on a
            <code class="literal">ClientBuilder</code> instance without wrapping them into the <code class="literal">SslContext</code>. However, if you setup
            a <code class="literal">SslContext</code> it will override any previously defined <code class="literal">KeyStore</code> and <code class="literal">TrustStore</code>
            settings.
            <code class="literal">ClientBuilder</code> also offers a method for defining a custom <a class="link" href="http://docs.oracle.com/javase/6/docs/api/javax/net/ssl/HostnameVerifier.html" target="_top">HostnameVerifier</a> implementation.
            <code class="literal">HostnameVerifier</code> implementations are invoked when default host URL verification fails.
        </p><div class="important" title="Important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                Note that to utilize HTTP with SSL it is necessary to utilize the <code class="literal">&#8220;https&#8221;</code> scheme.
            </p></div><p>
            Currently the default connector <code class="literal">HttpUrlConnector</code> based on <code class="literal">HttpUrlConnection</code> implements
            support for SSL defined by JAX-RS configuration discussed in this sample.
        </p><div class="section" title="5.8.1.&nbsp;HTTP Basic Authentication Support"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3300"></a>5.8.1.&nbsp;HTTP Basic Authentication Support</h3></div></div></div><p>
                Jersey contains a filter that allows client to authenticate to servers which requires HTTP Basic Authentication.
                Use <a class="link" href="https://jersey.java.net/apidocs/2.2/jersey/org/glassfish/jersey/client/filter/HttpBasicAuthFilter.html" target="_top">HttpBasicAuthFilter</a> to add authentication header to requests initiated from from the client.
                See the example of how to configure and register the filter:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">client.register(new HttpBasicAuthFilter("Homer", "SecretPassword"));</pre><p>
            </p></div></div></div><link href="https://jersey.java.net/sh/shCore.css" rel="stylesheet" type="text/css"><link href="https://jersey.java.net/sh/shThemeDefault.css" rel="stylesheet" type="text/css"><script src="https://jersey.java.net/sh/shCore.js" type="text/javascript"></script><script src="https://jersey.java.net/sh/shAutoloader.js" type="text/javascript"></script><script type="text/javascript">
            function path() {
              var args = arguments,
                  result = []
                  ;

              for(var i = 0; i < args.length; i++)
                  result.push(args[i].replace('@', 'https://jersey.java.net/sh/'));

              return result
            };

            SyntaxHighlighter.autoloader.apply(null, path(
              'applescript            @shBrushAppleScript.js',
              'actionscript3 as3      @shBrushAS3.js',
              'bash shell             @shBrushBash.js',
              'coldfusion cf          @shBrushColdFusion.js',
              'cpp c                  @shBrushCpp.js',
              'c# c-sharp csharp      @shBrushCSharp.js',
              'css                    @shBrushCss.js',
              'delphi pascal          @shBrushDelphi.js',
              'diff patch pas         @shBrushDiff.js',
              'erl erlang             @shBrushErlang.js',
              'groovy                 @shBrushGroovy.js',
              'java                   @shBrushJava.js',
              'jfx javafx             @shBrushJavaFX.js',
              'js jscript javascript  @shBrushJScript.js',
              'perl pl                @shBrushPerl.js',
              'php                    @shBrushPhp.js',
              'text plain             @shBrushPlain.js',
              'py python              @shBrushPython.js',
              'ruby rails ror rb      @shBrushRuby.js',
              'sass scss              @shBrushSass.js',
              'scala                  @shBrushScala.js',
              'sql                    @shBrushSql.js',
              'vb vbnet               @shBrushVb.js',
              'xml xhtml xslt html    @shBrushXml.js'
            ));

            SyntaxHighlighter.all();
        </script><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="deployment.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="representations.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;4.&nbsp;Deploying a RESTful Web Service&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;6.&nbsp;Representations and Responses</td></tr></table></div></div></body></html>